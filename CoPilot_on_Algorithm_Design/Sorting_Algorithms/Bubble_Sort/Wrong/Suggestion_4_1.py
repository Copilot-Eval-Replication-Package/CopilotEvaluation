



def selection_sort(arr):
    for i in range(0, len(arr)):
        min_index = i
        for j in range(i + 1, len(arr)):
            if arr[j] < arr[min_index]:
                min_index = j
        arr[i], arr[min_index] = arr[min_index], arr[i]
    return arr


if __name__ == "__main__":
    test = [random.randint(0, 100) for _ in range(10)]
    print(test)
    print(selection_sort(test))

#Compare this snippet from algorithm_design/sorting/merge_sort.py:
# create a function that recieves an array as input. it divides the input array into two halves, calls itself for the two halves, and then merges the two sorted halves.
# ! Below comment was generated by CoPilot ALONGSIDE the function. It also generated an algorithm for selection sort!
# # merge sort is a divide and conquer algorithm. it works by recursively splitting the array into smaller pieces until each piece is a single element. then, it combines the two sorted pieces.
# # the time complexity is O(n log n)
# # the space complexity is O(n)


def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    else:
        mid = len(arr) // 2
        left = merge_sort(arr[:mid])
        right = merge_sort(arr[mid:])
        return merge(left, right)


def merge(left, right):
    if not left:
        return right
    if not right:
        return left
    if left[0] > right[0]:
        return [right[0]] + merge(left, right[1:])
    else:
        return [left[0]] + merge(left[1:])